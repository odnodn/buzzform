{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "init",
  "title": "BuzzForm",
  "description": "Core BuzzForm components including Form, FormFields, FormSubmit, FormReset, and field rendering system. Requires setting up a provider - see documentation.",
  "dependencies": [
    "@buildnbuzz/buzzform"
  ],
  "registryDependencies": [
    "button",
    "field"
  ],
  "files": [
    {
      "path": "registry/base/form.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport type {\r\n  Field,\r\n  FormAdapter,\r\n  FormSettings,\r\n  UseFormOptions,\r\n} from \"@buildnbuzz/buzzform\";\r\nimport { useForm } from \"@buildnbuzz/buzzform\";\r\n\r\nimport {\r\n  RenderFields,\r\n  FieldRenderer,\r\n  type FieldRegistry,\r\n} from \"@/components/buzzform/fields/render\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { FieldGroup } from \"@/components/ui/field\";\r\n\r\n// Types\r\ntype ButtonProps = React.ComponentProps<typeof Button>;\r\n\r\n// Context\r\ninterface FormContextValue<TData = Record<string, unknown>> {\r\n  form: FormAdapter<TData>;\r\n  fields: readonly Field[];\r\n  registry?: FieldRegistry;\r\n  disabled: boolean;\r\n  requireDirty: boolean;\r\n  disableIfInvalid: boolean;\r\n}\r\n\r\nconst FormContext = React.createContext<FormContextValue | null>(null);\r\n\r\nfunction useFormContext<TData = Record<string, unknown>>() {\r\n  const ctx = React.useContext(FormContext);\r\n  if (!ctx) throw new Error(\"useFormContext must be used within <Form>\");\r\n  return ctx as FormContextValue<TData>;\r\n}\r\n\r\n// Form\r\ninterface FormProps<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n> extends UseFormOptions<TData> {\r\n  fields?: readonly Field[];\r\n  className?: string;\r\n  children?: React.ReactNode;\r\n  registry?: FieldRegistry;\r\n  disabled?: boolean;\r\n  requireDirty?: boolean;\r\n  disableIfInvalid?: boolean;\r\n  submitLabel?: string;\r\n  submitClassName?: string;\r\n  showSubmit?: boolean;\r\n}\r\n\r\nfunction FormRoot<TData extends Record<string, unknown>>(\r\n  {\r\n    schema,\r\n    fields: explicitFields,\r\n    defaultValues,\r\n    onSubmit,\r\n    mode,\r\n    settings: explicitSettings,\r\n    adapter,\r\n    className,\r\n    children,\r\n    registry,\r\n    disabled = false,\r\n    requireDirty = false,\r\n    disableIfInvalid = false,\r\n    submitLabel,\r\n    submitClassName,\r\n    showSubmit = true,\r\n  }: FormProps<TData>,\r\n  ref: React.ForwardedRef<FormAdapter<TData>>\r\n) {\r\n  const settings: FormSettings | undefined = (() => {\r\n    if (!explicitSettings && !requireDirty) return undefined;\r\n    return {\r\n      ...explicitSettings,\r\n      submitOnlyWhenDirty:\r\n        requireDirty || explicitSettings?.submitOnlyWhenDirty,\r\n    };\r\n  })();\r\n\r\n  const form = useForm<TData>({\r\n    schema,\r\n    defaultValues,\r\n    onSubmit,\r\n    mode,\r\n    settings,\r\n    adapter,\r\n  });\r\n\r\n  React.useImperativeHandle(ref, () => form);\r\n\r\n  const fields: readonly Field[] = (() => {\r\n    if (explicitFields) return explicitFields;\r\n    if (schema && \"fields\" in schema) return schema.fields as readonly Field[];\r\n    return [];\r\n  })();\r\n\r\n  const contextValue: FormContextValue<TData> = {\r\n    form,\r\n    fields,\r\n    registry,\r\n    disabled,\r\n    requireDirty,\r\n    disableIfInvalid,\r\n  };\r\n\r\n  const content = children ?? (\r\n    <FormContent className={className}>\r\n      <FormFields />\r\n      {showSubmit && (\r\n        <FormSubmit className={submitClassName}>{submitLabel}</FormSubmit>\r\n      )}\r\n    </FormContent>\r\n  );\r\n\r\n  return (\r\n    <FormContext.Provider value={contextValue as FormContextValue}>\r\n      {content}\r\n    </FormContext.Provider>\r\n  );\r\n}\r\n\r\nconst Form = React.forwardRef(FormRoot) as <\r\n  TData extends Record<string, unknown>,\r\n>(\r\n  props: FormProps<TData> & { ref?: React.ForwardedRef<FormAdapter<TData>> }\r\n) => React.ReactElement;\r\n\r\n// FormContent\r\nfunction FormContent({ className, ...props }: React.ComponentProps<\"form\">) {\r\n  const { form } = useFormContext();\r\n  return (\r\n    <form\r\n      data-slot=\"form-content\"\r\n      onSubmit={form.handleSubmit}\r\n      className={cn(\"space-y-4\", className)}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n// FormFields\r\nfunction FormFields({ className, ...props }: React.ComponentProps<\"div\">) {\r\n  const { fields, form, registry } = useFormContext();\r\n  return (\r\n    <FieldGroup\r\n      data-slot=\"field-group\"\r\n      className={cn(\"gap-2\", className)}\r\n      {...props}\r\n    >\r\n      <RenderFields fields={fields} form={form} registry={registry} />\r\n    </FieldGroup>\r\n  );\r\n}\r\n\r\n// FormField\r\nfunction FormField({\r\n  name,\r\n  className,\r\n  ...props\r\n}: React.ComponentProps<\"div\"> & { name: string }) {\r\n  const { fields, form, registry } = useFormContext();\r\n  const field = fields.find((f) => \"name\" in f && f.name === name);\r\n\r\n  if (!field) {\r\n    if (process.env.NODE_ENV === \"development\") {\r\n      console.warn(`FormField: Field \"${name}\" not found in schema.`);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <div data-slot=\"form-field\" className={className} {...props}>\r\n      <FieldRenderer\r\n        field={field}\r\n        path={name}\r\n        form={form}\r\n        registry={registry}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n\r\ntype FormActionProps = ButtonProps;\r\n\r\nfunction FormAction({\r\n  children,\r\n  disabled: propDisabled,\r\n  ...props\r\n}: FormActionProps) {\r\n  const { form, disabled: formDisabled } = useFormContext();\r\n  const { isSubmitting, isLoading } = form.formState;\r\n\r\n  return (\r\n    <Button\r\n      disabled={propDisabled || formDisabled || isSubmitting || isLoading}\r\n      {...props}\r\n    >\r\n      {children}\r\n    </Button>\r\n  );\r\n}\r\n\r\ntype FormSubmitProps = Omit<ButtonProps, \"disabled\"> & {\r\n  disabled?: boolean;\r\n  submittingText?: string;\r\n};\r\n\r\nfunction FormSubmit({\r\n  children,\r\n  className,\r\n  disabled: propDisabled,\r\n  variant,\r\n  size,\r\n  submittingText = \"Submitting...\",\r\n  ...props\r\n}: FormSubmitProps) {\r\n  const {\r\n    form,\r\n    disabled: formDisabled,\r\n    requireDirty,\r\n    disableIfInvalid,\r\n  } = useFormContext();\r\n  const { isSubmitting, isLoading, isDirty, isValid } = form.formState;\r\n\r\n  const isDisabled =\r\n    propDisabled ||\r\n    formDisabled ||\r\n    isSubmitting ||\r\n    isLoading ||\r\n    (requireDirty && !isDirty) ||\r\n    (disableIfInvalid && !isValid);\r\n\r\n  return (\r\n    <Button\r\n      type=\"submit\"\r\n      data-slot=\"form-submit\"\r\n      disabled={isDisabled}\r\n      variant={variant}\r\n      size={size}\r\n      className={className}\r\n      {...props}\r\n    >\r\n      {isSubmitting ? submittingText : children || \"Submit\"}\r\n    </Button>\r\n  );\r\n}\r\n\r\ntype FormResetProps = Omit<ButtonProps, \"disabled\" | \"onClick\"> & {\r\n  disabled?: boolean;\r\n};\r\n\r\nfunction FormReset({\r\n  children,\r\n  className,\r\n  disabled: propDisabled,\r\n  variant = \"outline\",\r\n  size,\r\n  ...props\r\n}: FormResetProps) {\r\n  const { form, disabled: formDisabled } = useFormContext();\r\n  const { isSubmitting, isDirty } = form.formState;\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      data-slot=\"form-reset\"\r\n      variant={variant}\r\n      size={size}\r\n      onClick={() => form.reset()}\r\n      disabled={propDisabled || formDisabled || isSubmitting || !isDirty}\r\n      className={className}\r\n      {...props}\r\n    >\r\n      {children || \"Reset\"}\r\n    </Button>\r\n  );\r\n}\r\n\r\n// FormActions\r\nfunction FormActions({\r\n  className,\r\n  align = \"end\",\r\n  ...props\r\n}: React.ComponentProps<\"div\"> & {\r\n  align?: \"start\" | \"center\" | \"end\" | \"between\";\r\n}) {\r\n  return (\r\n    <div\r\n      data-slot=\"form-actions\"\r\n      data-align={align}\r\n      className={cn(\r\n        \"flex gap-2\",\r\n        align === \"start\" && \"justify-start\",\r\n        align === \"center\" && \"justify-center\",\r\n        align === \"end\" && \"justify-end\",\r\n        align === \"between\" && \"justify-between\",\r\n        className\r\n      )}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n// FormMessage\r\nfunction FormMessage({\r\n  className,\r\n  children,\r\n  ...props\r\n}: React.ComponentProps<\"div\">) {\r\n  const { form } = useFormContext();\r\n  const rootError = form.formState.errors[\"\"] || form.formState.errors[\"root\"];\r\n  const message =\r\n    children || (typeof rootError === \"string\" ? rootError : null);\r\n\r\n  if (!message) return null;\r\n\r\n  return (\r\n    <div\r\n      role=\"alert\"\r\n      data-slot=\"form-message\"\r\n      className={cn(\r\n        \"rounded-md bg-destructive/10 px-3 py-2 text-sm text-destructive\",\r\n        className\r\n      )}\r\n      {...props}\r\n    >\r\n      {message}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Exports\r\nexport {\r\n  Form,\r\n  FormContent,\r\n  FormFields,\r\n  FormField,\r\n  FormSubmit,\r\n  FormReset,\r\n  FormAction,\r\n  FormActions,\r\n  FormMessage,\r\n  useFormContext,\r\n  type FormProps,\r\n};\r\n",
      "type": "registry:component",
      "target": "components/buzzform/form.tsx"
    },
    {
      "path": "registry/base/fields/render.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport type {\r\n  Field,\r\n  FormAdapter,\r\n  DataField,\r\n  FieldInputProps,\r\n  FieldComponentProps,\r\n  FieldType,\r\n} from \"@buildnbuzz/buzzform\";\r\nimport { generateFieldId, getNestedValue } from \"@buildnbuzz/buzzform\";\r\n\r\nimport type { ComponentType } from \"react\";\r\nimport {\r\n  TextField,\r\n  TextFieldSkeleton,\r\n} from \"@/components/buzzform/fields/text\";\r\nimport {\r\n  TextareaField,\r\n  TextareaFieldSkeleton,\r\n} from \"@/components/buzzform/fields/textarea\";\r\nimport {\r\n  CheckboxField,\r\n  CheckboxFieldSkeleton,\r\n} from \"@/components/buzzform/fields/checkbox\";\r\nimport {\r\n  PasswordField,\r\n  PasswordFieldSkeleton,\r\n} from \"@/components/buzzform/fields/password\";\r\nimport {\r\n  SwitchField,\r\n  SwitchFieldSkeleton,\r\n} from \"@/components/buzzform/fields/switch\";\r\nimport {\r\n  RadioField,\r\n  RadioFieldSkeleton,\r\n} from \"@/components/buzzform/fields/radio\";\r\nimport {\r\n  NumberField,\r\n  NumberFieldSkeleton,\r\n} from \"@/components/buzzform/fields/number\";\r\nimport {\r\n  TagsField,\r\n  TagsFieldSkeleton,\r\n} from \"@/components/buzzform/fields/tags\";\r\nimport {\r\n  DateField,\r\n  DateFieldSkeleton,\r\n} from \"@/components/buzzform/fields/date\";\r\nimport {\r\n  SelectField,\r\n  SelectFieldSkeleton,\r\n} from \"@/components/buzzform/fields/select\";\r\nimport {\r\n  UploadField,\r\n  UploadFieldSkeleton,\r\n} from \"@/components/buzzform/fields/upload\";\r\nimport { RowField, RowFieldSkeleton } from \"@/components/buzzform/fields/row\";\r\nimport {\r\n  GroupField,\r\n  GroupFieldSkeleton,\r\n} from \"@/components/buzzform/fields/group\";\r\nimport {\r\n  CollapsibleField,\r\n  CollapsibleFieldSkeleton,\r\n} from \"@/components/buzzform/fields/collapsible\";\r\nimport {\r\n  TabsField,\r\n  TabsFieldSkeleton,\r\n} from \"@/components/buzzform/fields/tabs\";\r\nimport {\r\n  ArrayField,\r\n  ArrayFieldSkeleton,\r\n} from \"@/components/buzzform/fields/array\";\r\n\r\nexport interface FieldRendererComponentProps {\r\n  field: Field;\r\n  path: string;\r\n  form: FormAdapter;\r\n  autoFocus?: boolean;\r\n  formValues: Record<string, unknown>;\r\n  siblingData: Record<string, unknown>;\r\n  // Computed props\r\n  fieldId: string;\r\n  label: React.ReactNode | null;\r\n  isDisabled: boolean;\r\n  isReadOnly: boolean;\r\n  error?: string;\r\n}\r\n\r\nexport interface FieldRegistryEntry {\r\n  kind: \"data\" | \"layout\";\r\n  renderer: ComponentType<FieldRendererComponentProps>;\r\n  skeleton?: ComponentType<{ field: Field }>;\r\n}\r\n\r\nexport type FieldRegistry = Partial<Record<FieldType, FieldRegistryEntry>>;\r\n\r\nexport function createFieldRegistry(entries: FieldRegistry): FieldRegistry {\r\n  return entries;\r\n}\r\n\r\nexport function mergeRegistries(...registries: FieldRegistry[]): FieldRegistry {\r\n  return Object.assign({}, ...registries);\r\n}\r\n\r\nexport const defaultFieldRegistry: FieldRegistry = createFieldRegistry({\r\n  text: {\r\n    kind: \"data\",\r\n    renderer: TextField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: TextFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  email: {\r\n    kind: \"data\",\r\n    renderer: TextField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: TextFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  textarea: {\r\n    kind: \"data\",\r\n    renderer: TextareaField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: TextareaFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  checkbox: {\r\n    kind: \"data\",\r\n    renderer: CheckboxField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: CheckboxFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  password: {\r\n    kind: \"data\",\r\n    renderer: PasswordField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: PasswordFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  switch: {\r\n    kind: \"data\",\r\n    renderer: SwitchField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: SwitchFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  radio: {\r\n    kind: \"data\",\r\n    renderer: RadioField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: RadioFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  number: {\r\n    kind: \"data\",\r\n    renderer: NumberField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: NumberFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  tags: {\r\n    kind: \"data\",\r\n    renderer: TagsField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: TagsFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  date: {\r\n    kind: \"data\",\r\n    renderer: DateField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: DateFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  datetime: {\r\n    kind: \"data\",\r\n    renderer: DateField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: DateFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  select: {\r\n    kind: \"data\",\r\n    renderer: SelectField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: SelectFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  upload: {\r\n    kind: \"data\",\r\n    renderer: UploadField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: UploadFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  row: {\r\n    kind: \"layout\",\r\n    renderer: RowField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: RowFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  group: {\r\n    kind: \"data\",\r\n    renderer: GroupField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: GroupFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  collapsible: {\r\n    kind: \"layout\",\r\n    renderer: CollapsibleField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: CollapsibleFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  tabs: {\r\n    kind: \"layout\",\r\n    renderer: TabsField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: TabsFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n  array: {\r\n    kind: \"data\",\r\n    renderer: ArrayField as ComponentType<FieldRendererComponentProps>,\r\n    skeleton: ArrayFieldSkeleton as ComponentType<{ field: Field }>,\r\n  },\r\n});\r\n\r\n// Types\r\nexport interface FieldRendererProps {\r\n  field: Field;\r\n  path: string;\r\n  form: FormAdapter;\r\n  registry?: FieldRegistry;\r\n  isFirstField?: boolean;\r\n}\r\n\r\nexport interface RenderFieldsProps {\r\n  fields: readonly Field[];\r\n  form: FormAdapter;\r\n  basePath?: string;\r\n  registry?: FieldRegistry;\r\n}\r\n\r\n// Helpers\r\nfunction isDataField(field: Field): field is DataField {\r\n  return \"name\" in field && field.name !== undefined;\r\n}\r\n\r\nfunction getSiblingData(\r\n  formValues: Record<string, unknown>,\r\n  path: string\r\n): Record<string, unknown> {\r\n  const pathParts = path.split(\".\");\r\n  const parentParts = pathParts.slice(0, -1);\r\n  if (parentParts.length === 0) return formValues;\r\n  const parent = getNestedValue(formValues, parentParts.join(\".\"));\r\n  return (parent as Record<string, unknown>) ?? formValues;\r\n}\r\n\r\nfunction getErrorMessage(\r\n  errors: Record<string, string | string[] | undefined>,\r\n  path: string\r\n): string | undefined {\r\n  const error = errors[path];\r\n  if (typeof error === \"string\") return error;\r\n  if (Array.isArray(error)) return error[0];\r\n  return undefined;\r\n}\r\n\r\n// Default skeleton\r\nfunction DefaultFieldSkeleton() {\r\n  return (\r\n    <div className=\"space-y-2\">\r\n      <div className=\"h-4 w-24 animate-pulse rounded bg-muted\" />\r\n      <div className=\"h-8 w-full animate-pulse rounded-lg bg-muted\" />\r\n    </div>\r\n  );\r\n}\r\n\r\n// Custom component renderer (field.component)\r\nfunction CustomComponentRenderer({\r\n  field,\r\n  path,\r\n  form,\r\n  formValues,\r\n  autoFocus,\r\n  fieldId,\r\n  isDisabled,\r\n  isReadOnly,\r\n  error,\r\n}: FieldRendererComponentProps & { field: DataField }) {\r\n  const CustomComponent = field.component as React.ComponentType<\r\n    FieldComponentProps<unknown, DataField>\r\n  >;\r\n  const value = getNestedValue(formValues, path);\r\n\r\n  return (\r\n    <CustomComponent\r\n      field={field}\r\n      path={path}\r\n      id={fieldId}\r\n      form={form}\r\n      value={value}\r\n      onChange={(val: unknown) =>\r\n        form.setValue(path, val, { shouldDirty: true })\r\n      }\r\n      onBlur={() => {\r\n        form.onBlur?.(path);\r\n      }}\r\n      disabled={isDisabled}\r\n      readOnly={isReadOnly}\r\n      error={error}\r\n      autoFocus={autoFocus}\r\n    />\r\n  );\r\n}\r\n\r\n// Custom input renderer (field.input)\r\nfunction CustomInputRenderer({\r\n  field,\r\n  path,\r\n  form,\r\n  formValues,\r\n  autoFocus,\r\n  fieldId,\r\n  label,\r\n  isDisabled,\r\n  isReadOnly,\r\n  error,\r\n}: FieldRendererComponentProps & { field: DataField }) {\r\n  const value = getNestedValue(formValues, path);\r\n\r\n  const inputProps: FieldInputProps = {\r\n    field,\r\n    path,\r\n    id: fieldId,\r\n    name: field.name,\r\n    value,\r\n    onChange: (val: unknown) => form.setValue(path, val, { shouldDirty: true }),\r\n    onBlur: () => {\r\n      form.onBlur?.(path);\r\n    },\r\n    disabled: isDisabled,\r\n    readOnly: isReadOnly,\r\n    error: error,\r\n    autoFocus,\r\n    validation: {\r\n      isChecking: form.formState.isValidating,\r\n      isValid: !error,\r\n      message: error,\r\n    },\r\n  };\r\n\r\n  const CustomInput = field.input;\r\n  const inputElement =\r\n    typeof CustomInput === \"function\" && !React.isValidElement(CustomInput)\r\n      ? (CustomInput as (props: FieldInputProps) => React.ReactNode)(inputProps)\r\n      : React.createElement(\r\n          CustomInput as React.ComponentType<FieldInputProps>,\r\n          inputProps\r\n        );\r\n\r\n  return (\r\n    <div\r\n      className={field.style?.className}\r\n      style={field.style?.width ? { width: field.style.width } : undefined}\r\n    >\r\n      {label && (\r\n        <label htmlFor={fieldId} className=\"block text-sm font-medium mb-1.5\">\r\n          {label}\r\n          {field.required && <span className=\"text-destructive ml-0.5\">*</span>}\r\n        </label>\r\n      )}\r\n\r\n      <div\r\n        ref={(el) => {\r\n          if (autoFocus && el) {\r\n            const focusable = el.querySelector<HTMLElement>(\r\n              'input, textarea, select, button, [tabindex]:not([tabindex=\"-1\"])'\r\n            );\r\n            focusable?.focus();\r\n          }\r\n        }}\r\n      >\r\n        {inputElement}\r\n      </div>\r\n\r\n      {field.description && (\r\n        <p className=\"text-sm text-muted-foreground mt-1.5\">\r\n          {field.description}\r\n        </p>\r\n      )}\r\n\r\n      {error && (\r\n        <p className=\"text-sm text-destructive mt-1.5\" role=\"alert\">\r\n          {error}\r\n        </p>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\n// FieldRenderer\r\nexport function FieldRenderer({\r\n  field,\r\n  path,\r\n  form,\r\n  registry = defaultFieldRegistry,\r\n  isFirstField = false,\r\n}: FieldRendererProps) {\r\n  const formValues = form.getValues();\r\n  const siblingData = getSiblingData(formValues, path);\r\n\r\n  const isHidden = (() => {\r\n    if (!isDataField(field)) return false;\r\n    if (typeof field.hidden === \"function\")\r\n      return field.hidden(formValues, siblingData);\r\n    return field.hidden ?? false;\r\n  })();\r\n\r\n  const isConditionMet = (() => {\r\n    if (!isDataField(field)) return true;\r\n    if (field.condition) {\r\n      return field.condition(formValues, siblingData, {\r\n        operation: \"update\",\r\n        path: path.split(\".\"),\r\n      });\r\n    }\r\n    return true;\r\n  })();\r\n\r\n  // Derived properties calculation\r\n  const fieldId =\r\n    isDataField(field) && field.id ? field.id : generateFieldId(path);\r\n\r\n  const label = (() => {\r\n    // Layout fields (like collapsible, tabs) have label but no name\r\n    if (\"label\" in field && field.label !== false) {\r\n      return field.label ?? null;\r\n    }\r\n    // Data fields use label or fallback to name\r\n    if (isDataField(field) && field.label !== false) {\r\n      return field.label ?? field.name ?? null;\r\n    }\r\n    return null;\r\n  })();\r\n\r\n  const isDisabled = (() => {\r\n    if (!isDataField(field)) return false;\r\n    const disabled =\r\n      typeof field.disabled === \"function\"\r\n        ? field.disabled(formValues, siblingData)\r\n        : (field.disabled ?? false);\r\n    return disabled || form.formState.isSubmitting;\r\n  })();\r\n\r\n  const isReadOnly = (() => {\r\n    if (!isDataField(field)) return false;\r\n    return typeof field.readOnly === \"function\"\r\n      ? field.readOnly(formValues, siblingData)\r\n      : (field.readOnly ?? false);\r\n  })();\r\n\r\n  const error = getErrorMessage(form.formState.errors, path);\r\n\r\n  const shouldAutoFocus = (() => {\r\n    if (!isDataField(field)) return false;\r\n    return (\r\n      isFirstField && form.settings?.autoFocus && !isDisabled && !isReadOnly\r\n    );\r\n  })();\r\n\r\n  if (isHidden || !isConditionMet) return null;\r\n\r\n  const registryEntry = registry[field.type];\r\n\r\n  if (form.formState.isLoading) {\r\n    if (registryEntry?.skeleton) {\r\n      const Skeleton = registryEntry.skeleton;\r\n      return <Skeleton field={field} />;\r\n    }\r\n    return <DefaultFieldSkeleton />;\r\n  }\r\n\r\n  if (isDataField(field) && field.component) {\r\n    return (\r\n      <CustomComponentRenderer\r\n        field={field}\r\n        path={path}\r\n        form={form}\r\n        formValues={formValues}\r\n        siblingData={siblingData}\r\n        autoFocus={shouldAutoFocus}\r\n        fieldId={fieldId}\r\n        label={label}\r\n        isDisabled={isDisabled}\r\n        isReadOnly={isReadOnly}\r\n        error={error}\r\n      />\r\n    );\r\n  }\r\n\r\n  if (isDataField(field) && field.input) {\r\n    return (\r\n      <CustomInputRenderer\r\n        field={field}\r\n        path={path}\r\n        form={form}\r\n        formValues={formValues}\r\n        siblingData={siblingData}\r\n        autoFocus={shouldAutoFocus}\r\n        fieldId={fieldId}\r\n        label={label}\r\n        isDisabled={isDisabled}\r\n        isReadOnly={isReadOnly}\r\n        error={error}\r\n      />\r\n    );\r\n  }\r\n\r\n  if (!registryEntry) {\r\n    return (\r\n      <div className=\"rounded border border-destructive bg-destructive/10 p-2 text-xs text-destructive\">\r\n        Unsupported field type: <code className=\"font-mono\">{field.type}</code>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const Renderer = registryEntry.renderer;\r\n  return (\r\n    <Renderer\r\n      field={field}\r\n      path={path}\r\n      form={form}\r\n      autoFocus={shouldAutoFocus}\r\n      formValues={formValues}\r\n      siblingData={siblingData}\r\n      fieldId={fieldId}\r\n      label={label}\r\n      isDisabled={isDisabled}\r\n      isReadOnly={isReadOnly}\r\n      error={error}\r\n    />\r\n  );\r\n}\r\n\r\n// RenderFields\r\nexport function RenderFields({\r\n  fields,\r\n  form,\r\n  basePath = \"\",\r\n  registry,\r\n}: RenderFieldsProps) {\r\n  let firstFieldName: string | null = null;\r\n  for (const field of fields) {\r\n    if (\"name\" in field && field.name) {\r\n      firstFieldName = field.name;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return (\r\n    <>\r\n      {fields.map((field, index) => {\r\n        const hasName = \"name\" in field && field.name;\r\n        const fieldPath = hasName\r\n          ? basePath\r\n            ? `${basePath}.${field.name}`\r\n            : field.name\r\n          : basePath;\r\n\r\n        const key = hasName ? field.name : `${field.type}-${index}`;\r\n        const isFirstField = !!(hasName && field.name === firstFieldName);\r\n\r\n        return (\r\n          <FieldRenderer\r\n            key={key}\r\n            field={field}\r\n            path={fieldPath}\r\n            form={form}\r\n            registry={registry}\r\n            isFirstField={isFirstField}\r\n          />\r\n        );\r\n      })}\r\n    </>\r\n  );\r\n}\r\n\r\nexport default FieldRenderer;\r\n",
      "type": "registry:component",
      "target": "components/buzzform/fields/render.tsx"
    }
  ],
  "type": "registry:ui"
}